	if (e->cast_id == H && e->cast.d == SHRT_MIN)
		e->cast.l *= -1;
		return (e->is_limit = 1);
	if (e->cast_id == HH && e->cast.d <= CHAR_MIN)
		e->cast.l *= -1;
		return (e->is_limit = 1);
	if ((e->cast.l >= LONG_MAX || e->cast.l <= LONG_MIN))
		e->cast.l *= -1;
		return (e->is_limit = 1);
	if (e->cast.d >= UINT_MAX)
		e->cast.l *= -1;
		return (e->is_limit = 1);
	if ((e->cast.d > INT_MAX || e->cast.d <= INT_MIN))
		e->cast.l *= -1;
		return (e->is_limit = 1);
	return (e->is_limit = 0);
	if (e->cast_id == H && e->ucast.d == SHRT_MIN)
		return (e->is_limit = 1);
	if (e->cast_id == HH && e->ucast.d <= CHAR_MIN)
		return (e->is_limit = 1);
	if (e->cast.d < 0 && e->flags.opt.decal)
		e->flags.width--;
	e->cast.ll = va_arg(e->arg, long long);
	if (!e->cast.ll && e->flags.opt.precis)
		e->flags.opt.decal = ' ';
	e->cast_sign = put_minus(e, pos, tmp);
	if ((e->cast.ll >= LLONG_MAX || e->cast.ll <= LLONG_MIN))
		if (e->cast.ll >= LLONG_MAX)
			e->cast_sign = 1;
			e->cast_sign = -1;
		e->cast_size = ft_ultoa_str(e->cast.ll, tmp);
	if (e->cast.ll == 0 && e->flags.opt.precis && !e->flags.precis)
	e->cast.ll *= e->cast_sign;
	e->cast.ll = va_arg(e->arg, long long);
	if ((e->cast.ll >= LLONG_MAX || e->cast.ll <= LLONG_MIN))
		if (e->cast.ll >= LLONG_MAX)
			e->cast_size = ft_ultoa_str(e->cast.ll, tmp);
			e->cast_sign = -1;
			e->cast_size = ft_ultoa_str(e->cast.ll, tmp);
	if (e->flags.opt.sign == ' ' || e->flags.opt.sign == '+')
		*tmp++ = (e->flags.opt.sign == ' ') ? ' ' : '+';
	e->cast_size = e->cast_size + ((e->flags.opt.sign) ? 1 : 0);
	if (e->cast_id == L)
	arg = va_arg(e->arg, char *);
		if (!e->flags.opt.precis)
		e->cast_size = ft_strlen(arg);
		if (e->cast_size >= BUFF_SIZE || !arg)
			print_output((void *)0, &e->cast_size, e);
	arg = va_arg(e->arg, unsigned int *);
		ft_strcpy(&e->output[*pos], "(null)");
		e->cast_size = ft_putstr_uni(arg, tmp);
	e->flags.conv = 's';
	e->cast.ll = va_arg(e->arg, long long);
	e->flags.opt.sign = 'x';
	if (e->cast.ll == 0 && e->flags.opt.precis && !e->flags.precis)
	e->cast_size = ft_ltoa_base(e->cast.l, tmp, 16);
	e->ucast.ll = va_arg(e->arg, long long int);
	if ((e->flags.opt.hash && e->ucast.ll &&
			(e->flags.precis <= e->cast_size)) ||
			(e->flags.opt.hash && e->ucast.ll && !e->flags.opt.precis))
		e->flags.opt.sign = '0';
		e->flags.opt.sign = 0;
	if (e->ucast.ll == 0 && e->flags.opt.precis &&
			!e->flags.precis && !e->flags.opt.hash)
	e->ucast.ll = va_arg(e->arg, long long int);
	if (e->ucast.ll == 0 && e->flags.opt.precis &&
			!e->flags.precis && !e->flags.opt.hash)
	if ((e->flags.opt.hash && e->ucast.ll &&
			(e->flags.precis <= e->cast_size)) ||
			(e->flags.opt.hash && e->ucast.ll && !e->flags.opt.precis))
		e->flags.opt.sign = '0';
		e->flags.opt.sign = 0;
	e->ucast.ll = va_arg(e->arg, unsigned long long);
	e->flags.opt.sign = 0;
	if (e->ucast.ll == 0 && e->flags.opt.precis && !e->flags.precis)
	e->ucast.ll = va_arg(e->arg, unsigned long long);
	e->flags.opt.sign = 0;
	e->ucast.ll = va_arg(e->arg, unsigned long long);
	if (e->ucast.ll == 0 && e->flags.opt.precis && !e->flags.precis)
	if (e->flags.opt.hash && e->ucast.ll)
		e->flags.conv = 'p';
		e->flags.opt.sign = 'x';
		e->flags.opt.sign = 0;
	if (!e->ucast.d && e->flags.opt.hash)
		e->cast_size = 1;
	e->ucast.ll = va_arg(e->arg, long long int);
	if (e->ucast.ll == 0 && e->flags.opt.precis && !e->flags.precis)
	if (e->flags.opt.hash && e->ucast.ll)
		e->flags.conv = 'p';
		e->flags.opt.sign = 'X';
		e->flags.opt.sign = 0;
	if (e->cast_id == HH)
		e->cast_size = ft_cap_ultoa_base(e->ucast.hh, tmp, 16);
	else if (e->cast_id == L || e->cast_id == LL)
		e->cast_size = ft_cap_ultoa_base(e->ucast.ll, tmp, 16);
		e->cast_size = ft_cap_ultoa_base(e->ucast.d, tmp, 16);
	print_output(e->output, pos, e);
	if (e->flags.width && !e->flags.opt.min)
		while (--e->flags.width)
			e->output_size += write(1, &e->flags.opt.decal, 1);
	e->output_size += write(1, "\0", 1);
	if (e->flags.width && e->flags.opt.min)
		while (--e->flags.width)
			e->output_size += write(1, &e->flags.opt.fill_prec, 1);
	if (e->cast_id == L)
	if (!e->cast.c)
		e->cast.c = va_arg(e->arg, unsigned int);
	e->cast_size = 1;
	if (e->cast.c)
		*tmp = e->cast.c;
		e->flags.precis = 1;
	e->ucast.d = va_arg(e->arg, unsigned int);
	if (e->ucast.d)
		e->cast_size = ft_putuni_str(e->ucast.d, tmp);
	e->conv['d'] = &d_conv;
	e->conv['D'] = &capd_conv;
	e->conv['i'] = &d_conv;
	e->conv['s'] = &s_conv;
	e->conv['S'] = &caps_conv;
	e->conv['p'] = &p_conv;
	e->conv['o'] = &o_conv;
	e->conv['O'] = &capo_conv;
	e->conv['u'] = &u_conv;
	e->conv['U'] = &capu_conv;
	e->conv['x'] = &x_conv;
	e->conv['X'] = &capx_conv;
	e->conv['c'] = &c_conv;
	e->conv['C'] = &capc_conv;
	if ((e->cast_id = is_cast(*str)) > 0)
		*str += (e->cast_id == LL || e->cast_id == HH) ? 2 : 1;
	if (e->cast_id == HH && (e->flags.conv == 'd' || e->flags.conv == 'i'))
		e->cast_size = ft_itoa_str(e->cast.hh, tmp);
	else if (e->cast_id == H && e->flags.conv == 'd')
		e->cast_size = ft_itoa_str(e->cast.h, tmp);
	else if (e->cast_id == L)
		e->cast_size = ft_ltoa_str(e->cast.ll, tmp);
	else if (e->cast_id == LL)
		e->cast_size = ft_lltoa_str(e->cast.ll, tmp);
	else if (e->cast_id == J)
		e->cast_size = ft_itoa_str(e->cast.j, tmp);
	else if (e->cast_id == Z)
		e->cast_size = ft_itoa_str(e->cast.z, tmp);
	else if (e->flags.conv == 'D')
		e->cast_size = ft_lltoa_str(e->cast.ll, tmp);
		e->cast_size = ft_ltoa_str(e->cast.d, tmp);
	if (e->flags.conv == 'O' || e->flags.conv == 'U')
		e->cast_size += ft_ultoa_base(e->ucast.ll, tmp, base);
	else if (e->cast_id == HH)
		e->cast_size += ft_ultoa_base(e->ucast.hh, tmp, base);
	else if (e->cast_id == H)
		e->cast_size += ft_ultoa_base(e->ucast.h, tmp, base);
	else if (e->cast_id == L)
		e->cast_size += ft_ultoa_base(e->ucast.ll, tmp, base);
	else if (e->cast_id == LL)
		e->cast_size += ft_ultoa_base(e->ucast.ll, tmp, base);
	else if (e->cast_id == J)
		e->cast_size += ft_ultoa_base(e->ucast.l, tmp, base);
	else if (e->cast_id == Z)
		e->cast_size += ft_ultoa_base(e->ucast.z, tmp, base);
		e->cast_size += ft_ultoa_base(e->ucast.d, tmp, base);
	e->flags.conv = is_conv(**str);
	if (e->flags.conv != 0)
		opt_resolver(option, &e->flags.opt);
	e->flags.width = ft_atoi(*str);
	e->flags.opt.precis = 1;
	e->flags.precis = ft_atoi(*str);
	e->flags.opt.decal = ' ';
		exit(write(1, e->output, ft_strlen(e->output)));
		e->flags.conv = 'c';
		e->cast.c = **ptr;
	if (e->flags.conv != 's' && e->flags.conv != 'c' &&
			e->flags.conv != 'C' && e->flags.conv != 'S')
		*prec_pad = (e->cast_size < e->flags.precis) ?
			e->flags.precis - e->cast_size : 0;
		*prec_pad = (e->cast_size <= e->flags.precis) ?
			e->cast_size : (e->cast_size - e->flags.precis);
	if (e->flags.conv != 's' && e->flags.conv != 'c' &&
			e->flags.conv != 'C' && e->flags.conv != 'S')
			e->output[*pos] = '0';
		ft_strcpy(&e->output[*pos], e->out_tmp);
		*pos += e->cast_size;
		ft_strncpy(&e->output[*pos], e->out_tmp, *prec_pad);
		*i = e->flags.width - *prec_pad;
	if (e->flags.conv == 'p')
		e->output[*pos] = '0';
		e->flags.width -= 1;
	i = e->flags.width - (prec_pad + e->cast_size);
	if ((e->cast_sign > 0 && e->flags.opt.sign) || e->cast_sign < 0)
		e->output[*pos] = (e->cast_sign < 0) ? '-' : e->flags.opt.sign;
		i -= (e->cast_sign < 0) ? 0 : 1;
		e->output[*pos] = ' ';
	cast = (e->cast_size > e->flags.precis) ?
		e->cast_size : e->flags.precis;
	*prec_pad = (e->cast_size < e->flags.precis || !e->flags.opt.precis) ?
		e->cast_size : e->flags.precis;
	*wid_pad = e->flags.width - *prec_pad;
	*prec_pad = (e->flags.precis > e->cast_size) ?
		e->flags.precis - e->cast_size : 0;
	*wid_pad = e->flags.width - (e->cast_size + *prec_pad);
	if (e->flags.conv == 'p')
	if (e->flags.opt.sign && e->cast_sign > 0)
			e->output[*pos + posi++] = e->flags.opt.decal;
		ft_strncpy(&e->output[*pos + posi], e->out_tmp, prec_pad);
		prec_pad = ft_strlen(e->out_tmp);
		if (*e->out_tmp)
			ft_strncpy(&e->output[*pos], e->out_tmp, prec_pad);
	if (!e->is_limit && (e->flags.conv != 'c' &&
				e->flags.conv != 'C' && e->flags.conv != 's'
				&& e->flags.conv != 'S'))
		if (e->flags.conv == 'p' && e->flags.opt.decal == ' ')
			e->output[*pos + *posi] = '0';
			e->output[*pos + *posi] = e->flags.opt.sign;
		else if (e->flags.opt.sign && e->cast_sign >= 0 &&
				e->flags.opt.decal == ' ')
			e->output[*pos + *posi] = e->flags.opt.sign;
		else if (e->cast_sign < 0 && e->flags.opt.decal == ' ')
			e->output[*pos + *posi] = '-';
		e->output[*pos + posi++] = e->flags.opt.decal;
			e->output[*pos + posi++] = e->flags.opt.fill_prec;
		ft_strcpy(&e->output[*pos + posi], e->out_tmp);
		*pos += posi + e->cast_size;
		ft_strcpy(&e->output[*pos + posi], e->out_tmp);
		*pos += e->cast_size;
	NBR(e->is_limit);
	if ((e->cast_sign < 0 || e->flags.opt.sign) &&
			!e->is_limit)
		if (e->flags.conv == 'p')
			e->output[*pos] = '0';
		e->output[*pos] = (e->cast_sign < 0) ? '-' : e->flags.opt.sign;
	if (e->flags.width && e->flags.opt.min)
	else if ((e->flags.conv != 's' && e->flags.conv != 'c'
				&& e->flags.conv != 'C') && e->flags.conv)
	e->cast.ll = 0;
	e->ucast.ll = 0;
	e->flags.width = 0;
	e->flags.precis = 0;
	e->flags.size = 0;
	e->flags.conv = 0;
	e->flags.opt.min = 0;
	e->flags.opt.hash = 0;
	e->flags.opt.sign = 0;
	e->flags.opt.decal = 0;
	e->flags.opt.fill_prec = '0';
	e->flags.opt.precis = 0;
	e->cast_size = 0;
	e->cast_id = 0;
	e->cast_sign = 1;
	e->is_limit = 0;
	e->output_size += *i;
	conv = e->conv[e->flags.conv];
	e->flags.opt.fill_prec = '0'; //precision filler
	conv(e, pos, e->out_tmp);
		e->out_tmp[i++] = *ptr;
	*pos += ft_strncpy_ret(&e->output[*pos], e->out_tmp, i / 2);
	ft_bzero(e->out_tmp, i);
			if (e->flags.conv)
			if (e->flags.conv != 'c' && e->flags.conv != 'C')
			ft_bzero(e->out_tmp, sizeof(e->out_tmp));
	ptr = e->output;
		e->output[i++] = **str;
	e->output[i] = '\0';
